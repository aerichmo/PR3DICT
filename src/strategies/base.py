"""
PR3DICT: Base Strategy Interface

Abstract base class for trading strategies.
Follows ST0CK's Strategy Pattern for decoupled signal/execution logic.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from decimal import Decimal
from datetime import datetime

from ..platforms.base import Market, OrderSide, Position


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    market_id: str
    market: Market
    side: OrderSide
    strength: float  # 0.0 - 1.0 confidence
    reason: str
    target_price: Optional[Decimal] = None
    stop_price: Optional[Decimal] = None
    timestamp: datetime = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()


class TradingStrategy(ABC):
    """
    Abstract base strategy interface.
    
    Strategies implement the signal generation logic while
    the engine handles execution and lifecycle.
    """
    
    @property
    @abstractmethod
    def name(self) -> str:
        """Strategy identifier."""
        pass
    
    @property
    def enabled(self) -> bool:
        """Whether strategy is active."""
        return True
    
    @abstractmethod
    async def scan_markets(self, markets: List[Market]) -> List[Signal]:
        """
        Scan available markets for entry opportunities.
        
        Args:
            markets: List of active markets from platforms
            
        Returns:
            List of signals for markets meeting entry criteria
        """
        pass
    
    @abstractmethod
    async def check_exit(self, position: Position, market: Market) -> Optional[Signal]:
        """
        Check if an open position should be exited.
        
        Args:
            position: Current open position
            market: Latest market data
            
        Returns:
            Exit signal if should close, None otherwise
        """
        pass
    
    def get_position_size(self, 
                          signal: Signal, 
                          account_balance: Decimal,
                          risk_pct: float = 0.02) -> int:
        """
        Calculate position size based on signal and risk parameters.
        
        Default implementation uses fixed risk percentage.
        Override for Kelly Criterion or other sizing methods.
        """
        risk_amount = account_balance * Decimal(str(risk_pct))
        
        # For binary contracts, max loss is the entry price
        if signal.target_price:
            entry_price = signal.target_price
        else:
            entry_price = signal.market.yes_price if signal.side == OrderSide.YES else signal.market.no_price
        
        if entry_price > 0:
            contracts = int(risk_amount / entry_price)
            return max(1, contracts)
        return 1
